{- Render a `JSON` value as `Text`

   This is useful for debugging `JSON` values or for tests.  For anything
   more sophisticated you should use `dhall-to-json` or `dhall-to-yaml`

```
let JSON = ./package.dhall

in  JSON.renderYAML
    ( JSON.array
      [ JSON.bool True
      , JSON.string "Hello"
      , JSON.object
        [ { mapKey = "foo", mapValue = JSON.null       }
        , { mapKey = "bar", mapValue = JSON.number 1.0 }
        ]
      ]
    )
= "[ true, \"Hello\", { \"foo\": null, \"bar\": 1.0 } ]"
```
-}
let JSON =
        ./Type sha256:5adb234f5868a5b0eddeb034d690aaba8cb94ea20d0d557003e90334fff6be3e
      ? ./Type

let Text/concatSep = ../Text/concatSep

let List/drop = ../List/drop

let List/null = ../List/null

let List/map = ../List/map

let List/concatMap = ../List/concatMap

let Optional/map = ../Optional/map

let NonEmpty = λ(a : Type) → { head : a, tail : List a }

let uncons
    : ∀(a : Type) → List a → Optional (NonEmpty a)
    =   λ(a : Type)
      → λ(ls : List a)
      → Optional/map
          a
          (NonEmpty a)
          (λ(head : a) → { head = head, tail = List/drop 1 a ls })
          (List/head a ls)

let nonEmptyToList
    : ∀(a : Type) → NonEmpty a → List a
    = λ(a : Type) → λ(nonEmpty : NonEmpty a) → [ nonEmpty.head ] # nonEmpty.tail

let concatNonEmpty =
        λ(a : Type)
      → λ(lss : NonEmpty (NonEmpty a))
      → { head = lss.head.head
        , tail =
              lss.head.tail
            # List/concatMap (NonEmpty a) a (nonEmptyToList a) lss.tail
        }

let Block = NonEmpty Text

let indentBlockWith =
        λ(headIndent : Text)
      → λ(tailIndent : Text)
      → λ(block : Block)
      → { head = headIndent ++ block.head
        , tail = List/map Text Text (λ(t : Text) → tailIndent ++ t) block.tail
        }

let manyBlocks
    : Block → List Block → Block
    =   λ(ifEmpty : Block)
      → λ(blocks : List Block)
      → Optional/fold
          (NonEmpty Block)
          (uncons Block blocks)
          Block
          (concatNonEmpty Text)
          ifEmpty

let singleLine
    : Text → Block
    = λ(text : Text) → { head = text, tail = [] : List Text }

let indentKeyedBlock
    : Text → Text → Text → Block → Block
    =   λ(key : Text)
      → λ(spacer : Text)
      → λ(indentation : Text)
      → λ(block : Block)
      →       if List/null Text block.tail
        
        then  singleLine (key ++ spacer ++ block.head)
        
        else  indentBlockWith
                key
                indentation
                { head = "", tail = nonEmptyToList Text block }

let blockToText
    : Block → Text
    = λ(block : Block) → Text/concatSep "\n" (nonEmptyToList Text block) ++ "\n"

let render
    : JSON → Text
    =   λ(json : JSON)
      → let ObjectField = { mapKey : Text, mapValue : Block }
        
        in  blockToText
              ( json
                  Block
                  { string = λ(x : Text) → singleLine (Text/show x)
                  , number = λ(x : Double) → singleLine (Double/show x)
                  , object =
                        λ(fields : List ObjectField)
                      → let renderField
                            : ObjectField → Block
                            =   λ(e : ObjectField)
                              → indentKeyedBlock
                                  "${e.mapKey}:"
                                  " "
                                  "  "
                                  e.mapValue
                        
                        in  manyBlocks
                              (singleLine "{}")
                              (List/map ObjectField Block renderField fields)
                  , array =
                        λ(elements : List Block)
                      → manyBlocks
                          (singleLine "[]")
                          ( List/map
                              Block
                              Block
                              (indentBlockWith "- " "  ")
                              elements
                          )
                  , bool =
                      λ(x : Bool) → singleLine (if x then "true" else "false")
                  , null = singleLine "null"
                  }
              )

in  render
